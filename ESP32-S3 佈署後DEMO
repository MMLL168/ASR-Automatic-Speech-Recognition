/*
 * ESP32-S3 AI Monitor (Final Production - Tuned Logic)
 * Model: Float32 (Unoptimized)
 * Status: Calibrated for Marlon's Fan Data
 *
 * æ ¸å¿ƒè¨­å®š:
 * 1. Audio: Gain 5.0 / Divisor 256.0 (æ¨¡æ“¬ Data Forwarder è¡Œç‚º)
 * 2. Logic: 
 * - Error è§¸ç™¼é–€æª»: 0.85 (éæ¿¾æ‰å¹³æ™‚ 0.4~0.5 çš„æµ®å‹•)
 * - Fan èªå®šé–€æª»: 0.40 (æ¥å— 0.5 å·¦å³çš„ä¿¡å¿ƒåº¦ç‚ºæ­£å¸¸)
 */

// â˜… è«‹ç¢ºèª Library åç¨±æ˜¯å¦æ­£ç¢º
#include <ESP32S3_MIC_Add_Error_inferencing.h> 

#include <driver/i2s.h>
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_ILI9341.h>
#include <DHT.h> 

// ===== åƒæ•¸è¨­å®š =====
#define EI_SAMPLE_RATE       16000 
#define BEEP_VOLUME          0.05 
#define MIC_GAIN             5.0   
#define AUDIO_DIVISOR        256.0f // â˜… é—œéµ: ç¶­æŒ Data Forwarder çš„æ¯”ä¾‹

// ğŸ›  ç³»çµ±è¨­å®š
#define TFT_SPI_SPEED        80000000 
#define DIAGNOSTIC_MODE      false    // æ­£å¼ç‰ˆé—œé–‰é™¤éŒ¯æ–‡å­—

// ğŸ”¥ AI é–€æª»èª¿æ ¡ (æ ¹æ“šä½ çš„å¯¦æ¸¬æ•¸æ“š)
// ç•°å¸¸æ™‚æœƒè¡åˆ° 0.9 ä»¥ä¸Šï¼Œæ‰€ä»¥è¨­ 0.85 å¾ˆå®‰å…¨
#define THRESHOLD_ERROR      0.85     
// æ­£å¸¸æ™‚ Fan ç´„ 0.4~0.6ï¼Œæ‰€ä»¥è¨­ 0.40 è®“å®ƒå®¹æ˜“è¢«èªå®šç‚ºæ­£å¸¸
#define THRESHOLD_FAN        0.40     
// èƒŒæ™¯éŸ³é€šå¸¸å¾ˆæ˜ç¢º
#define THRESHOLD_BACKG      0.70     

// æ¬¡æ•¸è¨­å®š (å»æŠ–å‹•)
#define DEBOUNCE_ERROR       2    // é€£çºŒ 2 æ¬¡ Error æ‰å ±è­¦ (é˜²èª¤åˆ¤)
#define DEBOUNCE_FAN         2
#define DEBOUNCE_BACKG       2    

// ===== ç¡¬é«”è…³ä½ =====
#define DHTPIN  1
#define DHTTYPE DHT11

#define PIN_RED   10
#define PIN_GREEN 11
#define PIN_BLUE  12

#define MIC_WS 4
#define MIC_SCK 5
#define MIC_SD 6
#define I2S_MIC_PORT I2S_NUM_1

#define SPK_DIN 7
#define SPK_BCLK 15
#define SPK_LRC 16
#define I2S_SPK_PORT I2S_NUM_0

#define OLED_ADDR 0x3C
#define I2C_SDA 41
#define I2C_SCL 42
#define TFT_CS 45
#define TFT_DC 47
#define TFT_RST 21
#define TFT_MOSI 20
#define TFT_SCK 19
#define TFT_BL 38

// é¡è‰²å®šç¾©
#define C_BLACK   0x0000
#define C_WHITE   0xFFFF
#define C_RED     0xF800
#define C_GREEN   0x07E0
#define C_BLUE    0x001F
#define C_CYAN    0x07FF
#define C_GREY    0x2124 

// ç‰©ä»¶å®£å‘Š
Adafruit_SSD1306 oled(128, 64, &Wire, -1);
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_MOSI, TFT_SCK, TFT_RST);
DHT dht(DHTPIN, DHTTYPE);

// ç³»çµ±ç‹€æ…‹
enum DetectionState { STATE_UNKNOWN, STATE_BACKGROUND, STATE_FAN_ON, STATE_ERROR };

struct SystemState {
  bool oledOK = false;
  bool tftOK = false;
  bool micOK = false;
  bool spkOK = false;
  DetectionState currentState = STATE_UNKNOWN;
  DetectionState lastState = STATE_UNKNOWN;
  
  float temp = 0.0;
  float hum = 0.0;
  float score_fan = 0.0;
  float score_background = 0.0; 
  float score_error = 0.0; 
  
  uint16_t currentBgColor = C_BLACK;
  uint16_t currentTxtColor = C_WHITE;
} sys;

float *ai_buffer = NULL;
int16_t *audio_out_buffer = NULL;

int fan_consecutive_count = 0;   
int background_consecutive_count = 0; 
int error_consecutive_count = 0; 

// å‡½å¼åŸå‹
void setRGB(bool r, bool g, bool b);
void updateSensors();
bool initMic();
bool initSpk();
void playBeep(int freq, int ms);
void playAlarmSound();
void playFanOnSound();
void playFanOffSound();
void record_audio_for_ai(float *out_buf);
void handleStateChange(DetectionState state);
void drawLayout();
void updateHeader(String text, uint16_t bg, uint16_t fg);
void updateNumbers();

// ===================================
// Setup
// ===================================
void setup() {
  Serial.begin(115200);
  delay(1000); 
  Serial.println("Label:Fan,Label:Background,Label:Error,Label:Temp,Label:Humi");

  pinMode(PIN_RED, OUTPUT); pinMode(PIN_GREEN, OUTPUT); pinMode(PIN_BLUE, OUTPUT);
  setRGB(0, 0, 0);
  dht.begin();

  audio_out_buffer = (int16_t*)malloc(512 * 4); 
  if(psramFound()){
    ai_buffer = (float*)ps_malloc(EI_CLASSIFIER_RAW_SAMPLE_COUNT * sizeof(float));
  } else {
    ai_buffer = (float*)malloc(EI_CLASSIFIER_RAW_SAMPLE_COUNT * sizeof(float));
  }
  if (!ai_buffer) while(1);

  pinMode(TFT_BL, OUTPUT); digitalWrite(TFT_BL, HIGH);
  Wire.begin(I2C_SDA, I2C_SCL);
  if(oled.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    sys.oledOK = true; oled.clearDisplay(); oled.display();
  }
  
  pinMode(TFT_RST, OUTPUT);
  digitalWrite(TFT_RST, HIGH);
  delay(50);
  
  tft.begin();
  tft.setRotation(2); 
  tft.setSPISpeed(TFT_SPI_SPEED); 
  tft.fillScreen(C_BLACK);
  sys.tftOK = true;

  sys.micOK = initMic(); 
  sys.spkOK = initSpk();
  
  playBeep(880, 50); 
  updateSensors(); 
  drawLayout(); 
  updateHeader("READY", C_BLACK, C_GREEN); 
}

// ===================================
// Loop
// ===================================
void loop() {
  updateSensors();
  
  // 1. éŒ„éŸ³ (æ¨¡æ“¬ Data Forwarder)
  record_audio_for_ai(ai_buffer);

  // 2. AI æ¨è«–
  signal_t signal;
  numpy::signal_from_buffer(ai_buffer, EI_CLASSIFIER_RAW_SAMPLE_COUNT, &signal);
  ei_impulse_result_t result = { 0 };
  run_classifier(&signal, &result, false);

  sys.score_fan = 0; sys.score_background = 0; sys.score_error = 0;

  for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
    String label = String(result.classification[ix].label);
    float value = result.classification[ix].value;
    
    if (label.equalsIgnoreCase("Fan")) sys.score_fan = value;
    else if (label.equalsIgnoreCase("Error") || label.equalsIgnoreCase("anomaly")) sys.score_error = value;
    else sys.score_background = value;
  }

  Serial.printf("Fan:%.2f\tBackground:%.2f\tError:%.2f\tTemp:%.1f\tHumi:%.1f\n", 
                sys.score_fan, sys.score_background, sys.score_error, sys.temp, sys.hum);

  // 3. ğŸ”¥ã€é‚è¼¯åˆ¤å®šå„ªåŒ–ã€‘ğŸ”¥
  // ç­–ç•¥ï¼šå„ªå…ˆæª¢æŸ¥ Error (é–€æª»é«˜)ï¼Œå…¶æ¬¡ Backgroundï¼Œæœ€å¾Œæ²’äº‹å°±ç•¶ Fan (é–€æª»ä½)

  bool is_error = (sys.score_error >= THRESHOLD_ERROR);
  bool is_background = (sys.score_background >= THRESHOLD_BACKG);
  // Fan çš„åˆ¤å®šæ”¾å¯¬ï¼šåªè¦ä¸æ˜¯ Error ä¸” Fan åˆ†æ•¸ > 0.4 å°±ç®—
  bool is_fan = (!is_error && sys.score_fan >= THRESHOLD_FAN);

  if (is_error) {
    error_consecutive_count++;
    fan_consecutive_count = 0; background_consecutive_count = 0;
  } else if (is_background) {
    background_consecutive_count++;
    fan_consecutive_count = 0; error_consecutive_count = 0;
  } else if (is_fan) {
    // å¦‚æœ Fan åˆ†æ•¸ç¨ä½(0.5) ä½†æ²’è§¸ç™¼ Errorï¼Œæˆ‘å€‘å°±èªå®šæ˜¯ Fan
    fan_consecutive_count++;
    error_consecutive_count = 0; background_consecutive_count = 0;
  } else {
    // æ¨¡ç³Šåœ°å¸¶ (ä¾‹å¦‚ Fan=0.3, Err=0.3, Back=0.4)ï¼Œä¿æŒä¸Šä¸€å€‹ç‹€æ…‹æˆ–æ­¸é›¶
    // é€™è£¡é¸æ“‡æ­¸é›¶é‡è¨ˆï¼Œé¿å…èª¤åˆ¤
    fan_consecutive_count = 0; error_consecutive_count = 0; background_consecutive_count = 0;
  }

  // è§¸ç™¼ç‹€æ…‹
  bool trigger_error = (error_consecutive_count >= DEBOUNCE_ERROR);
  bool trigger_fan = (fan_consecutive_count >= DEBOUNCE_FAN);
  bool trigger_background = (background_consecutive_count >= DEBOUNCE_BACKG);

  if (trigger_error) {
    sys.currentState = STATE_ERROR;
    error_consecutive_count = DEBOUNCE_ERROR; // é–å®š
  } else if (trigger_background) {
    sys.currentState = STATE_BACKGROUND;
    background_consecutive_count = DEBOUNCE_BACKG; 
  } else if (trigger_fan) {
    sys.currentState = STATE_FAN_ON;
    fan_consecutive_count = DEBOUNCE_FAN; 
  }

  // 4. åŸ·è¡Œå‹•ä½œ
  if (sys.currentState != sys.lastState) {
    handleStateChange(sys.currentState);
    if(sys.currentState == STATE_ERROR) playAlarmSound();
    else if(sys.currentState == STATE_FAN_ON) playFanOnSound();
    else if(sys.currentState == STATE_BACKGROUND) playFanOffSound();
    sys.lastState = sys.currentState;
  }

  updateNumbers();
}

// ===================================
// é—œéµï¼šæ¨¡æ“¬ Data Forwarder éŒ„éŸ³å‡½å¼
// ===================================
void record_audio_for_ai(float *out_buf) {
  size_t bytes_read; 
  int32_t i2s_buffer[512]; 
  int samples_read = 0;

  float gain = 5.0f;
  float divisor = 256.0f; 

  while (samples_read < EI_CLASSIFIER_RAW_SAMPLE_COUNT) {
    i2s_read(I2S_MIC_PORT, i2s_buffer, sizeof(i2s_buffer), &bytes_read, portMAX_DELAY);
    if (bytes_read == 0) continue;

    int samples_in_chunk = bytes_read / 4; 
    
    for (int i = 0; i < samples_in_chunk; i++) {
      if (samples_read < EI_CLASSIFIER_RAW_SAMPLE_COUNT) {
        int32_t raw = i2s_buffer[i] >> 8; 

        // æ¨¡æ“¬ Data Forwarder çš„ int16 æº¢ä½è¡Œç‚º
        int32_t temp_calc = (int32_t)((raw * gain) / divisor);
        int16_t simulated_val = (int16_t)temp_calc; 
        
        out_buf[samples_read] = (float)simulated_val; 
        
        samples_read++;
      }
    }
  }
}

// ===================================
// UI & Drivers
// ===================================
void handleStateChange(DetectionState state) {
  String statusText = "";
  uint16_t bgColor = C_BLACK; uint16_t txtColor = C_WHITE;
  switch (state) {
    case STATE_ERROR: statusText = "ERROR"; bgColor = C_RED; setRGB(1, 0, 0); break;
    case STATE_FAN_ON: statusText = "FAN ON"; bgColor = C_GREEN; txtColor = C_BLACK; setRGB(0, 1, 0); break;
    case STATE_BACKGROUND: statusText = "STANDBY"; bgColor = C_BLACK; txtColor = C_GREEN; setRGB(0, 0, 1); break;
    default: setRGB(0, 0, 0); break;
  }
  sys.currentBgColor = bgColor; sys.currentTxtColor = txtColor;
  updateHeader(statusText, bgColor, txtColor);
}

void drawLayout() {
  if (!sys.tftOK) return;
  tft.fillScreen(C_BLACK); tft.setTextColor(C_WHITE); tft.setTextSize(2);
  tft.setCursor(20, 90); tft.print("Temp:"); tft.setCursor(20, 120); tft.print("Humi:");
  tft.setCursor(20, 160); tft.print("Fan  :"); 
  tft.setCursor(20, 190); tft.print("Backg:");
  tft.setCursor(20, 220); tft.print("Error:"); 
  tft.drawFastHLine(10, 80, 220, C_WHITE); tft.drawRect(5, 5, 230, 310, C_WHITE);
}

void updateHeader(String text, uint16_t bg, uint16_t fg) {
  if (sys.tftOK) {
    tft.fillRect(6, 6, 228, 70, bg); tft.setTextColor(fg); tft.setTextSize(4);
    int x = (240 - (text.length() * 24)) / 2; if (x < 0) x = 0;
    tft.setCursor(x, 25); tft.println(text);
  }
  if (sys.oledOK) {
    oled.clearDisplay(); oled.setTextColor(SSD1306_WHITE); oled.setTextSize(2);
    oled.setCursor(0, 0); oled.println(text); oled.display();
  }
}

void updateNumbers() {
  if (sys.tftOK) {
    tft.setTextColor(C_CYAN, C_BLACK); tft.setTextSize(2); char buf[10];
    sprintf(buf, "%4.1f C", sys.temp); tft.setCursor(100, 90); tft.print(buf);
    sprintf(buf, "%4.1f %%", sys.hum); tft.setCursor(100, 120); tft.print(buf);

    if(sys.score_fan > THRESHOLD_FAN) tft.setTextColor(C_GREEN, C_BLACK); else tft.setTextColor(C_WHITE, C_BLACK);
    sprintf(buf, "%3.0f%%", sys.score_fan * 100); tft.setCursor(120, 160); tft.print(buf);
    
    if(sys.score_background > THRESHOLD_BACKG) tft.setTextColor(C_GREEN, C_BLACK); else tft.setTextColor(C_WHITE, C_BLACK);
    sprintf(buf, "%3.0f%%", sys.score_background * 100); tft.setCursor(120, 190); tft.print(buf);

    if(sys.score_error > THRESHOLD_ERROR) tft.setTextColor(C_RED, C_BLACK); else tft.setTextColor(C_GREY, C_BLACK);
    sprintf(buf, "%3.0f%%", sys.score_error * 100); tft.setCursor(120, 220); tft.print(buf);
    
    int maxW = 140;
    tft.fillRect(60, 250, maxW, 6, C_GREY); tft.fillRect(60, 250, (int)(sys.score_fan * maxW), 6, C_GREEN);
    tft.fillRect(60, 265, maxW, 6, C_GREY); tft.fillRect(60, 265, (int)(sys.score_background * maxW), 6, C_BLUE);
    tft.fillRect(60, 280, maxW, 6, C_GREY); tft.fillRect(60, 280, (int)(sys.score_error * maxW), 6, C_RED);
  }
  if (sys.oledOK) {
      oled.fillRect(0, 20, 128, 44, SSD1306_BLACK); oled.setTextColor(SSD1306_WHITE); oled.setTextSize(1); 
      oled.setCursor(0, 25); oled.printf("T:%.1f H:%.0f%%", sys.temp, sys.hum);
      oled.setCursor(0, 36); oled.printf("F:%.0f%% B:%.0f%%", sys.score_fan*100, sys.score_background*100);
      oled.setCursor(0, 48); oled.printf("Err: %.0f%%", sys.score_error*100);
      oled.display();
  }
}

void setRGB(bool r, bool g, bool b) { digitalWrite(PIN_RED, r); digitalWrite(PIN_GREEN, g); digitalWrite(PIN_BLUE, b); }
void updateSensors() { float h = dht.readHumidity(); float t = dht.readTemperature(); if (!isnan(h) && !isnan(t)) { sys.hum = h; sys.temp = t; } }
void playAlarmSound() { if(!sys.spkOK) return; for(int i=0; i<3; i++) { playBeep(1200, 100); playBeep(800, 100); } }
void playFanOnSound() { if(sys.spkOK) { playBeep(523, 100); playBeep(659, 100); playBeep(784, 100); playBeep(1046, 200); } }
void playFanOffSound() { if(sys.spkOK) { playBeep(784, 150); playBeep(659, 150); playBeep(523, 300); } }
void playBeep(int freq, int ms) {
  if(!audio_out_buffer) return;
  int samples = (EI_SAMPLE_RATE * ms) / 1000;
  int written_total = 0;
  while(written_total < samples) {
    int chunk = min(512, samples - written_total);
    for(int i = 0; i < chunk; i++) {
      float t = (float)(written_total + i) / EI_SAMPLE_RATE;
      int16_t s = (int16_t)(sin(2 * PI * freq * t) * 32767 * BEEP_VOLUME);
      audio_out_buffer[i * 2] = s; audio_out_buffer[i * 2 + 1] = s;
    }
    size_t w; i2s_write(I2S_SPK_PORT, audio_out_buffer, chunk * 4, &w, portMAX_DELAY);
    written_total += chunk;
  }
  i2s_zero_dma_buffer(I2S_SPK_PORT);
}
bool initMic() {
  i2s_config_t cfg = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX), .sample_rate = EI_SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT, .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S, .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 4, .dma_buf_len = 512, .use_apll = false, .tx_desc_auto_clear = false, .fixed_mclk = 0
  };
  i2s_pin_config_t pin = { .bck_io_num = MIC_SCK, .ws_io_num = MIC_WS, .data_out_num = -1, .data_in_num = MIC_SD };
  return (i2s_driver_install(I2S_MIC_PORT, &cfg, 0, NULL) == ESP_OK && i2s_set_pin(I2S_MIC_PORT, &pin) == ESP_OK);
}
bool initSpk() {
  i2s_config_t cfg = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX), .sample_rate = EI_SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT, .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S, .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 4, .dma_buf_len = 512, .use_apll = false, .tx_desc_auto_clear = true, .fixed_mclk = 0
  };
  i2s_pin_config_t pin = { .bck_io_num = SPK_BCLK, .ws_io_num = SPK_LRC, .data_out_num = SPK_DIN, .data_in_num = -1 };
  return (i2s_driver_install(I2S_SPK_PORT, &cfg, 0, NULL) == ESP_OK && i2s_set_pin(I2S_SPK_PORT, &pin) == ESP_OK);
}
